/******************************************************************************
 * This file was generated by langium-cli 0.3.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, isAstNode } from 'langium';

export type Cmd = For | Move | Pen;

export const Cmd = 'Cmd';

export function isCmd(item: unknown): item is Cmd {
    return reflection.isInstance(item, Cmd);
}

export type Expr = BinExpr | Group | Lit | NegExpr | Ref;

export const Expr = 'Expr';

export function isExpr(item: unknown): item is Expr {
    return reflection.isInstance(item, Expr);
}

export type Stmt = Cmd | Macro;

export const Stmt = 'Stmt';

export function isStmt(item: unknown): item is Stmt {
    return reflection.isInstance(item, Stmt);
}

export interface BinExpr extends AstNode {
    readonly $container: BinExpr | For | Group | Macro | Move | NegExpr;
    e1: Expr
    e2: Expr
    op: BinOp
}

export const BinExpr = 'BinExpr';

export function isBinExpr(item: unknown): item is BinExpr {
    return reflection.isInstance(item, BinExpr);
}

export interface BinOp extends AstNode {
    readonly $container: BinExpr;
    val: 'add' | 'div' | 'mul' | 'sub'
}

export const BinOp = 'BinOp';

export function isBinOp(item: unknown): item is BinOp {
    return reflection.isInstance(item, BinOp);
}

export interface Block extends AstNode {
    readonly $container: Def | For;
    body: Array<Stmt>
}

export const Block = 'Block';

export function isBlock(item: unknown): item is Block {
    return reflection.isInstance(item, Block);
}

export interface Def extends AstNode {
    readonly $container: Model;
    b: Block
    name: string
    params: Array<string>
}

export const Def = 'Def';

export function isDef(item: unknown): item is Def {
    return reflection.isInstance(item, Def);
}

export interface For extends AstNode {
    readonly $container: Block | Model;
    b: Block
    e1: Expr
    e2: Expr
    var: string
}

export const For = 'For';

export function isFor(item: unknown): item is For {
    return reflection.isInstance(item, For);
}

export interface Group extends AstNode {
    readonly $container: BinExpr | For | Group | Macro | Move | NegExpr;
    ge: Expr
}

export const Group = 'Group';

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, Group);
}

export interface Lit extends AstNode {
    readonly $container: BinExpr | For | Group | Macro | Move | NegExpr;
    val: number
}

export const Lit = 'Lit';

export function isLit(item: unknown): item is Lit {
    return reflection.isInstance(item, Lit);
}

export interface Macro extends AstNode {
    readonly $container: Block | Model;
    args: Array<Expr>
    name: string
}

export const Macro = 'Macro';

export function isMacro(item: unknown): item is Macro {
    return reflection.isInstance(item, Macro);
}

export interface Model extends AstNode {
    defs: Array<Def>
    stmts: Array<Stmt>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Move extends AstNode {
    readonly $container: Block | Model;
    ex: Expr
    ey: Expr
}

export const Move = 'Move';

export function isMove(item: unknown): item is Move {
    return reflection.isInstance(item, Move);
}

export interface NegExpr extends AstNode {
    readonly $container: BinExpr | For | Group | Macro | Move | NegExpr;
    ne: Expr
}

export const NegExpr = 'NegExpr';

export function isNegExpr(item: unknown): item is NegExpr {
    return reflection.isInstance(item, NegExpr);
}

export interface Pen extends AstNode {
    readonly $container: Block | Model;
    mode: 'down' | 'up'
}

export const Pen = 'Pen';

export function isPen(item: unknown): item is Pen {
    return reflection.isInstance(item, Pen);
}

export interface Ref extends AstNode {
    readonly $container: BinExpr | For | Group | Macro | Move | NegExpr;
    val: string
}

export const Ref = 'Ref';

export function isRef(item: unknown): item is Ref {
    return reflection.isInstance(item, Ref);
}

export type MiniLogoAstType = 'BinExpr' | 'BinOp' | 'Block' | 'Cmd' | 'Def' | 'Expr' | 'For' | 'Group' | 'Lit' | 'Macro' | 'Model' | 'Move' | 'NegExpr' | 'Pen' | 'Ref' | 'Stmt';

export type MiniLogoAstReference = never;

export class MiniLogoAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['BinExpr', 'BinOp', 'Block', 'Cmd', 'Def', 'Expr', 'For', 'Group', 'Lit', 'Macro', 'Model', 'Move', 'NegExpr', 'Pen', 'Ref', 'Stmt'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case BinExpr:
            case Group:
            case Lit:
            case NegExpr:
            case Ref: {
                return this.isSubtype(Expr, supertype);
            }
            case For:
            case Move:
            case Pen: {
                return this.isSubtype(Cmd, supertype);
            }
            case Macro:
            case Cmd: {
                return this.isSubtype(Stmt, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: MiniLogoAstReference): string {
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new MiniLogoAstReflection();
