/******************************************************************************
 * This file was generated by langium-cli 0.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, ReferenceInfo, isAstNode, TypeMetaData } from 'langium';

export type Cmd = Color | For | Move | Pen;

export const Cmd = 'Cmd';

export function isCmd(item: unknown): item is Cmd {
    return reflection.isInstance(item, Cmd);
}

export type Expr = BinExpr | PrimExpr;

export const Expr = 'Expr';

export function isExpr(item: unknown): item is Expr {
    return reflection.isInstance(item, Expr);
}

export type PrimExpr = Group | Lit | NegExpr | Ref;

export const PrimExpr = 'PrimExpr';

export function isPrimExpr(item: unknown): item is PrimExpr {
    return reflection.isInstance(item, PrimExpr);
}

export type Stmt = Cmd | Macro;

export const Stmt = 'Stmt';

export function isStmt(item: unknown): item is Stmt {
    return reflection.isInstance(item, Stmt);
}

export interface BinExpr extends AstNode {
    readonly $container: BinExpr | Color | For | Group | Macro | Move | NegExpr;
    e1: Expr | PrimExpr
    e2: Expr | PrimExpr
    op: '*' | '+' | '-' | '/'
}

export const BinExpr = 'BinExpr';

export function isBinExpr(item: unknown): item is BinExpr {
    return reflection.isInstance(item, BinExpr);
}

export interface Color extends AstNode {
    readonly $container: Def | For | Model;
    b?: Expr
    color?: string
    g?: Expr
    r?: Expr
}

export const Color = 'Color';

export function isColor(item: unknown): item is Color {
    return reflection.isInstance(item, Color);
}

export interface Def extends AstNode {
    readonly $container: Model;
    body: Array<Stmt>
    name: string
    params: Array<Param>
}

export const Def = 'Def';

export function isDef(item: unknown): item is Def {
    return reflection.isInstance(item, Def);
}

export interface For extends AstNode {
    readonly $container: Def | For | Model;
    body: Array<Stmt>
    e1: Expr
    e2: Expr
    var: Param
}

export const For = 'For';

export function isFor(item: unknown): item is For {
    return reflection.isInstance(item, For);
}

export interface Group extends AstNode {
    readonly $container: BinExpr | Color | For | Group | Macro | Move | NegExpr;
    ge: Expr
}

export const Group = 'Group';

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, Group);
}

export interface Lit extends AstNode {
    readonly $container: BinExpr | Color | For | Group | Macro | Move | NegExpr;
    val: number
}

export const Lit = 'Lit';

export function isLit(item: unknown): item is Lit {
    return reflection.isInstance(item, Lit);
}

export interface Macro extends AstNode {
    readonly $container: Def | For | Model;
    args: Array<Expr>
    def: Reference<Def>
}

export const Macro = 'Macro';

export function isMacro(item: unknown): item is Macro {
    return reflection.isInstance(item, Macro);
}

export interface Model extends AstNode {
    defs: Array<Def>
    stmts: Array<Stmt>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Move extends AstNode {
    readonly $container: Def | For | Model;
    ex: Expr
    ey: Expr
}

export const Move = 'Move';

export function isMove(item: unknown): item is Move {
    return reflection.isInstance(item, Move);
}

export interface NegExpr extends AstNode {
    readonly $container: BinExpr | Color | For | Group | Macro | Move | NegExpr;
    ne: Expr
}

export const NegExpr = 'NegExpr';

export function isNegExpr(item: unknown): item is NegExpr {
    return reflection.isInstance(item, NegExpr);
}

export interface Param extends AstNode {
    readonly $container: Def | For;
    name: string
}

export const Param = 'Param';

export function isParam(item: unknown): item is Param {
    return reflection.isInstance(item, Param);
}

export interface Pen extends AstNode {
    readonly $container: Def | For | Model;
    mode: 'down' | 'up'
}

export const Pen = 'Pen';

export function isPen(item: unknown): item is Pen {
    return reflection.isInstance(item, Pen);
}

export interface Ref extends AstNode {
    readonly $container: BinExpr | Color | For | Group | Macro | Move | NegExpr;
    val: Reference<Param>
}

export const Ref = 'Ref';

export function isRef(item: unknown): item is Ref {
    return reflection.isInstance(item, Ref);
}

export type MiniLogoAstType = 'BinExpr' | 'Cmd' | 'Color' | 'Def' | 'Expr' | 'For' | 'Group' | 'Lit' | 'Macro' | 'Model' | 'Move' | 'NegExpr' | 'Param' | 'Pen' | 'PrimExpr' | 'Ref' | 'Stmt';

export class MiniLogoAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['BinExpr', 'Cmd', 'Color', 'Def', 'Expr', 'For', 'Group', 'Lit', 'Macro', 'Model', 'Move', 'NegExpr', 'Param', 'Pen', 'PrimExpr', 'Ref', 'Stmt'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case BinExpr:
            case PrimExpr: {
                return this.isSubtype(Expr, supertype);
            }
            case Color:
            case For:
            case Move:
            case Pen: {
                return this.isSubtype(Cmd, supertype);
            }
            case Group:
            case Lit:
            case NegExpr:
            case Ref: {
                return this.isSubtype(PrimExpr, supertype);
            }
            case Macro:
            case Cmd: {
                return this.isSubtype(Stmt, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Macro:def': {
                return Def;
            }
            case 'Ref:val': {
                return Param;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Def': {
                return {
                    name: 'Def',
                    mandatory: [
                        { name: 'body', type: 'array' },
                        { name: 'params', type: 'array' }
                    ]
                };
            }
            case 'For': {
                return {
                    name: 'For',
                    mandatory: [
                        { name: 'body', type: 'array' }
                    ]
                };
            }
            case 'Macro': {
                return {
                    name: 'Macro',
                    mandatory: [
                        { name: 'args', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'defs', type: 'array' },
                        { name: 'stmts', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new MiniLogoAstReflection();
